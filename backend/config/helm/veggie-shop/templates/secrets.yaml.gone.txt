{{- /*
secrets.yaml.gone.README
------------------------

This chart does not ship a `secrets.yaml` template on purpose.
Storing secrets in Git is unsafe and strongly discouraged.

Recommended approaches:
1) **External Secrets Operator (ESO)** (preferred for production):
   - Enable it via values:
       externalSecret.enabled=true
       externalSecret.name=veggieshop-app-secrets
       externalSecret.secretStoreRef.kind=ClusterSecretStore
       externalSecret.secretStoreRef.name=<your-store>
   - Map each key from your secret store under `externalSecret.data`.
   - The resulting Kubernetes Secret will be created automatically by ESO
     and mounted into the Deployment using `envFrom.secrets` values.

2) **Manually create a Secret** for local/dev:
   - Keep the manifest outside of the repository and apply it on the cluster:
       kubectl -n <ns> create secret generic veggieshop-app-secrets \
         --from-literal=SPRING_DATASOURCE_USERNAME=veggie \
         --from-literal=SPRING_DATASOURCE_PASSWORD=veggie \
         --from-literal=JWT_SECRET=dev-jwt-secret \
         --from-literal=MINIO_ACCESS_KEY=minio \
         --from-literal=MINIO_SECRET_KEY=minio123
   - Ensure the Deployment references it via values:
       envFrom.secrets[0].name=veggieshop-app-secrets

Notes:
- Adjust secret keys to match your application's expectations.
- See values.yaml for the complete list of environment variables and the ExternalSecret shape.
- If you insist on templating a Secret for non-production use, place it in a **separate private repo**
  or keep it in your CI/CD system (sealed/encrypted) and template it during the pipeline, not here.
*/ -}}
